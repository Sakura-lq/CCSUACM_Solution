# P13142 [GCJ 2018 #1C] A Whole New Word

## Solution

#### 题意:我们有一个N*L的字符矩阵,然后需要从每一列中选择一个，组成一个新的单词,也就是与原来给出的每行单词不同的字符串

下面是本题的几个小细节点 __o(=•ェ•=)m__：
1. 题目给出的内存非常大,于是乎可以考虑使用 **trie(字典树)** 解决,因为字典树的性质决定了,它可以快速查询是否存在该单词,时间复杂度为 ``O(n)``

2. 但是又因为此题数据量很小,所以就算使用暴力也是可以过题的,我看题解没有使用 **trie** 解决的,所以本 **蒟蒻** 来写一篇

----

#### 字典树的定义
下图是借用 *OI-WIKI* 上的图
![alt text](https://oi-wiki.org/string/images/trie1.png)
字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。举个例子, ``1 → 4 → 8 → 12``
表示的就是字符串 ``caa``。

根据字典树的结构特征,我们可以知道,从根节点到某个节点的路径就是一个字符串,因此其实我们只需要将初始的所有字符串全都插入进trie中,那么对于每一个 ***dfs构造得到的字符串***, 我们只需要查找是否存在一个从根节点到某个节点的路径,如果这条路径存在,则说明不是新的单词, 如果不存在则将其加入 ``ans`` 中.

插入字符串进入字典树的操作:
```cpp
void insert(char *s, int l) {  // 插入字符串
    int p = 0;
    for (int i = 0; i < l; i++) {
      int c = s[i] - 'a';
      if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点
      p = nex[p][c];
    }
    exist[p] = true;
  }
```
----

查询字符串进入字典树的操作:

```cpp
bool find(char *s, int l) {  // 查找字符串
    int p = 0;
    for (int i = 0; i < l; i++) {
      int c = s[i] - 'a';
      if (!nex[p][c]) return 0;
      p = nex[p][c];
    }
    return exist[p];
}
```
----

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define double long double
#define endl '\n'

const int MAXN = 1e6;
int trie[MAXN][26];
bool ed[MAXN];
int cnt;

int n, l;

void insert(const string &s)
{
    int p = 0;
    for (char ch : s)
    {
        int c = ch - 'A';
        if (!trie[p][c])
        {
            trie[p][c] = ++cnt;
        }
        p = trie[p][c];
    }

    ed[p] = true;
}

bool dfs(int d, int p, vector<vector<char>> &col, string &cur, string &ans)
{
    if (d == l)
    {
        if (!ed[p])
        {
            ans = cur;
            return true;
        }
        return false;
    }

    for (char c : col[d])
    {
        int x = c - 'A';
        cur.push_back(c);

        if (trie[p][x] == 0)
        {
            ans = cur;
            for (int j = d + 1; j < l; j++)
            {
                ans.push_back(col[j][0]);
            }
            return true;
        }

        if (dfs(d + 1, trie[p][x], col, cur, ans))
        {
            return true;
        }
        cur.pop_back();
    }

    return false;
}

void clear()
{
    memset(trie, 0, sizeof(trie));
    memset(ed, 0, sizeof(ed));
    cnt = 0;
}

void solve()
{
    int T;
    cin >> T;

    for (int k = 1; k <= T; k++)
    {
        cin >> n >> l;

        clear();

        vector<string> words(n);
        for (int i = 0; i < n; i++)
        {
            cin >> words[i];
        }

        vector<set<char>> colset(l);
        for (auto &w : words)
        {
            for (int i = 0; i < l; i++)
            {
                colset[i].insert(w[i]);
            }
        }

        vector<vector<char>> col(l);
        for (int i = 0; i < l; i++)
        {
            col[i] = vector<char>(colset[i].begin(), colset[i].end());
        }

        for (auto &w : words)
        {
            insert(w);
        }

        string cur = "", ans = "";

        cout << "Case #" << k << ": " << (dfs(0, 0, col, cur, ans) ? ans : "-") << endl;
    }
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    solve();
    return 0;
}
```

*ps*: 本篇题解是本蒟蒻第二篇题解也是第一次使用 `md` 文本,难免会有很多错落,恳请各位大佬不吝赐教 __orz__ ༼ つ ◕_◕ ༽つ

附一个卖萌的 _gif_:  
![alt text](1754473160928-1.gif)
